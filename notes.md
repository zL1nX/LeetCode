# 部分题目记录
> 按照知识点归类不同题目，方便后续集中查看回忆

## 链表
- 206反转链表 [reverseList.cpp](./reverseList.cpp)
  - 递归的美妙写法，`reverse(head->next)`, node->next成了最后一个节点, 注意reverse函数的定义
  - **相同题目**: [JZOffer24-反转链表](./reverseList2.cpp), [JZOffer24II-反转链表](./reverseList3.cpp)
  - **相似题目**: [92-反转链表 II](./reverseBetween2.cpp), firstNode节点的定义, 以及先反转前N个节点(比较烧脑的递归)

> 注意: 递归虽然代码非常美妙, 理解也挺烧脑, 但效率是不如迭代的, 要真面试的话, 还是得准备一手迭代的解法


- 876链表的中间结点 [middleNode.cpp](./middleNode.cpp)
  - 每次快指针比慢指针多走一步，慢指针就自然到中间了
- 面试题 02.02. 返回倒数第 k 个节点 [kthToLast](./kthToLast.cpp)
  - 和上面一道题类似,也是快慢指针,让快指针先走k步,慢指针再开始走,经典的思路
  - **相似题目**
    - [JZOfferII021-删除链表的倒数第 n 个结点](./removeNthFromEnd2.cpp), slow指向删的节点, 并保存一个前驱指针, 如果要删除头节点该怎么办
- 面试题02.01.移除重复节点 [removeDuplicateNodes](./removeDuplicateNodes.cpp)
  - 删除节点 + 哈希表，这两个东西结合一下，会产生很多容易写错的细节，多注意一些
- JZOffer18. 删除链表的节点 [deleteNode](./deleteNode3.cpp)
  - 单纯的单链表节点删除, 注意dummy节点的设置以及删除完后直接break
  - **相似题目**: [203-移除链表元素](./removeElements2.cpp), 这一题需要删除多个节点, 注意与上面这个题的不同(cur的移动条件)
- 面试题02.06 回文链表 [isPalindrome](./isPalindromeList.cpp)
  - 链表也能后序遍历？能后序遍历就能实现回文（在递归中left向后走，right每层递归结束都会向前）。非常妙
  - **相同题目**: [JZOfferII027-回文链表](./isPalindromeList2.cpp) (注意递归return的条件)
- 剑指Offer 06. 从尾到头打印链表 [reversePrint](./reversePrint.cpp)
  - 链表的后序遍历（递归法），就是上面那道题的简化版
- 面试题 02.07. 链表相交 [getIntersectionNode](./getIntersectionNode3.cpp)
  - 经典的相交链表问题, 当一个指针走完自己的链表时,让它去遍历另外的链表,这相当于对两条链表的不同部分取并集. 非常经典的思路
  - **相同题目**: [JZOfferII023-两个链表的第一个重合节点](./getIntersectionNode4.cpp) (注意**如果没有相交节点时要返回null时**该怎么办)
- 剑指Offer 25-合并两个排序的链表 [mergeTwoLists](./mergeTwoLists.cpp)
  - 一个while循环 + 两个if判断; 关键在于新链表指针每次都是`cur->next`去操作,cur只用移到`cur->next`即可,省去了空节点的麻烦. 最开始cur就是dummy自己
  - **相同题目**: [21-合并两个有序链表](./mergeTwoLists2.cpp)
  - **相似题目** 
    - [面试题02.05-链表求和](./addTwoNumbers.cpp): 基于链表的按位加模拟过程, 记得设置进位
    - [JZOfferII025-链表中的两数相加](./addTwoNumbers2.cpp): 反向的上一题, 栈的使用 + 反向构建链表(node->next = cur)
    - [23-合并K个升序链表](./mergeKLists.cpp), 优先队列中初始放入所有的头节点, 自己只完成指针的移动即可
    - [61-旋转链表](./rotateRight2.cpp), `p->next=head` 以及移动的是`len-k%len`个节点, 剩余的就是节点next的拆分与更新
- 面试题17.12-BiNode BST展开为链表 [convertBiNode](./convertBiNode.cpp)
  - 本质是BST中序遍历 + 修改指针, 注意left指针修改时要修改当前节点而非上一个节点的.
  - **相似题目**
    - [114-二叉树展开为链表](./flatten2.cpp), 经典的递归定义题目, 核心在于考虑清楚单节点的处理方式, 以及需要在原地空间完成
    - [JZOfferII028-展平多级双向链表](./flattenMultiLevelNode.cpp), 同样从DFS的定义出发, 定义好lastNode后对两端进行操作即可
- 109-有序链表转换二叉搜索树 有序链表构造为BST [sortedListToBST](./sortedListToBST.cpp)
  - 本质是BST中序遍历构造 + 二分, 递归的模板题
  - **相似题目** : [JZOffer36-二叉搜索树与双向链表](./treeToDoublyList.cpp), 直接中序遍历 + 节点的指针修改, 注意递归结束后首尾节点的处理
- 24-两两交换链表中的节点 [swapPairs](./swapPairs2.cpp), 模拟即可, 静下心来想一下就能解决
- 146-LRU 缓存, 经典的面试题, 双向链表 + 哈希表, 需要掌握对功能的分解, LRU的原理, (双向)链表的各种操作.
  - 因为要查找 + 时序 + 删除与插入 , 所以只能双向链表 (删除与插入) + 哈希表 (查找) , 以实现快速的时序
  - 操作过的元素就放在链表最后, 由此头元素就是最久没有被使用的元素
  - 哈希表中存储节点, 负责新元素的get与set, 链表用来维护元素之间的新旧顺序
  - 注意双向链表的插入与删除操作, 语句之间的顺序
- 142-环形链表 II, 经典链表的环相交问题, 快指针比慢指针多走一步, 之后快指针从头开始继续走, 直到相遇 (**画图理解**)
  - 注意: 两指针的相遇点不一定是环的起点!
  - **相同题目**: [JZOfferII022-链表中环的入口节点](./detectCycle3.cpp) (注意可能没有环的返回结构), [面试题02.08-环路检测](./detectCycle4.cpp)
- 面试题04.03-特定深度节点链表: [面试题04.03-特定深度节点链表](./listOfDepth.cpp), BFS层序遍历的模板题目, 兼顾树和链表的结点类型
- JZOffer35-复杂链表的复制 : [copyRandomList](./copyRandomList2.cpp) 两次遍历 + 哈希表方便新建节点 (似乎有更巧妙的方法如dfs, 拆分等)
- 面试题02.04-分割链表[partitionList](./partitionList.cpp), 一个小指针, 一个大指针, 大指针最后别忘了置空
  - **相似题目**: 
    - [JZOfferII026-重排链表](./reorderList2.cpp), 需要用vector来存, 然后跟交换节点很像, 记得最后的节点next置空以及left++


## 树与二叉树

- [104-二叉树的最大深度](./treemaxDepth.cpp): 有多种解法, 考虑分而治之(动规)的思想, 即左子树的最大高度和右子树的最大高度的最大值+1, 就是当前节点的最大深度
  - 后序位置上的遍历, 非常经典的题目, 还可以直接dfs全局变量, bfs遍历等思路去做
  - **相似题目**
    - [543-二叉树的直径](./diameterOfBinaryTree.cpp), 当前节点的最长直径 = 左右子树的最大深度之和, 同样还是后序位置的遍历, 思路与104相同, 只不过单个节点上的操作多了一些.
    - [687-最长同值路径](./longestUnivaluePath.cpp), 与上一题非常像, 但有了路径上的值必须相等的要求, 方法是递归时传入一个parentVal, 来让当前这一支和父节点的值保持相等

- [226-翻转二叉树](./invertTree.cpp), 前序和后序位置都可以做, 因为单独到一个节点就是交换左右子树即可, 前序和后序对于这个题而言只是遍历方向不同
- [116-填充每个节点的下一个右侧节点指针](./connectPadNextTree.cpp), 如何访问同辈节点? 递归的时候怎么就抽象成了三叉树?
- [114-二叉树展开为链表](./flatten3.cpp): 典中典之将树展开为链表, 递归求解子问题的经典题目, 即先展开左右子树, 再把左子树接到右子树, 右子树接到新的右子树后面
- [654-最大二叉树](./constructMaximumBinaryTree2.cpp), 分解问题 or 遍历思想? 只取决于怎么理解问题. 对于单个节点而言, 在[left, right] 这个范围里找到最大值后构造节点, 剩下的交给递归.
- 从X序和X序构造二叉树: 给定两个数组, 分别表示前/中/后序的节点, 来构造一颗二叉树 (人脑手写很简单, 那么代码实现呢?)
  - 两个关键点: (1) 快速定位到当前的**根节点** (前序是开始位置, 后序是结束位置); (2) 下一步递归时的**边界计算**, 在中序数组中根据根节点索引和start, 得到**左子树的大小**leftSize, 进行推算
  - 相关题目: [105-从前序与中序遍历序列构造二叉树](./buildTreePreandMid.cpp), [106-从中序与后序遍历序列构造二叉树](./buildTreePostandMid.cpp), [889-根据前序和后序遍历构造二叉树](./constructFromPrePost.cpp), 这一题有些不同, 就是**左子树的大小是不确定**的, 可以强制认为前序中根节点后面那个就是左子树根节点, 然后再用leftSize那些操作.
- [297-二叉树的序列化与反序列化](./Codec2.cpp), 序列化很好实现, 就是前序遍历, 无非自己定义下分隔符和空指针用什么来表示; 反序列化的前序构造要注意两个地方, 对空指针的判定, 和前序构造时全局索引的使用
  - **相似题目**: 
    - [449-序列化和反序列化二叉搜索树](./CodecForBST.cpp), 如果是BST的话, 那就无需空指针了, 通过minv和maxv来判断当前节点值在不在这棵树中
    - [652-寻找重复的子树](./findDuplicateSubtrees.cpp), 序列化仍然是基础, 之后的操作是基于哈希表来判定重复, 注意不要重复添加结果
- [230-二叉搜索树中第K小的元素](./kthSmallest2.cpp), BST的性质让题目理解起来不是很难, 如果用递归去写, 那么就是在遍历的时候维护一个rank记录大小顺序即可
  - 诚然, 也可以用循环的方式去写, 此时手动声明一个stack来存储节点, 人工模拟递归时的迭代方法, 同样还是同时去判断k, 本质和递归是一样的
- [538-把二叉搜索树转换为累加树](./convertSumBST.cpp), 遍历BST得到降序序列/前缀和/etc, right和left的递归位置变一下即可
- [98-验证二叉搜索树](./isValidBST.cpp), 单个节点的BST验证 + 递归时增加maxn minn来进行势力范围的比较
- [701-二叉搜索树中的插入操作](./insertIntoBST.cpp), BST的查找 + 修改. 查找就是二分递归, 修改的话, 如果查找的进程落到了一个null节点的话, 那就得新建一个新节点了, 这就是修改. 记得返回值注意下
- [450-删除二叉搜索树中的节点](./deleteBSTNode.cpp), BST的查找 + 删除, 查找依然遵循着二分递归的框架, 删除的情况略微复杂些: 叶子节点(直接返回空), 只有一个子树(返回这个子树根), 有两个子树(找右子树的最小结点替换当前root作为根)
- [965-单值二叉树](./isUnivalTree.cpp), 判断一个二叉树是否由单单一个值组成, 直接递归判断即可
- [236-二叉树的最近公共祖先], 有点费脑的递归, 前序来保证自身节点选中, 后序保证祖先是深度最深的, 最终left和right哪个非空返回哪个
  - **相似题目**: [235-二叉搜索树的最近公共祖先](./lowestCommonAncestorBST.cpp), 利用BST的性质简化判断
  - tips: 这类题有一个比较核心的点就是, 公共祖先是树结点朝着祖先方向延长线的交点, 而上面两道题的解法框架都涵盖了这一点
- [513-找树左下角的值](./findBottomLeftValue.cpp): 遍历的思想去解决, 遍历时维护一个最大深度, 同时要记得回溯保证当前深度的值是正确的
- [669-修剪二叉搜索树](./trimBST.cpp): 站在一个节点上考虑怎么处理. 当节点值符合要求时只用考虑子树; 如果节点不符合要求, 那就考虑左右两子树谁符合要求


## 动态规划

- [322-零钱兑换](./coinChange.cpp)
  -  **dp含义**-金额为i时所需的最少硬币数量
  -  **状态转移**-`dp[i]=min(dp[i], dp[i-1] + 1)`, 即再多一个硬币就能从金额i-1凑到i
  -  此外注意下初始值的设定问题
- [300-最长递增子序列](./lengthOfLIS.cpp)
  -  **dp含义**-在位置为i的地方LIS的长度 (双层循环)
  -  **状态转移**-双层循环找比当前nums[i]小的最大的dp[j]+1,就是dp[i]
- [354-俄罗斯套娃信封问题](./maxEnvelopes2.cpp) : 先按宽升序排列, **宽相等的**再按照高降序排列
  -  直接N方的dp在lc上会超时, 需要用耐心排序的二分实现达到NlogN的复杂度, 每次二分查找找比当前牌小的堆顶, 堆数就是LIS
- [931-下降路径最小和](./minFallingPathSum.cpp): 二维dp, 边界值和初始值的设定比较容易出错
  -  **dp含义**-在位置ij处的最小路径和
  -  **状态转移**-当前matrix_ij的权重加上上一层dp的最小值 (最小值来自三个方向, 为维护代码统一性, 需考虑边界问题和缺省值的设定)
- [72-编辑距离](./EditDistance.cpp): 大名鼎鼎的编辑距离, dp还是递归, 异曲同工, 都是靠上一层的结果直接求解这一层的结果
  - **dp含义**-对于dp[i][j]表示s1[0..i]变换到s2[0..j]的最小次数 (即编辑距离这一答案本身)
  - **base case**-当s1或s2有任意一方为空字符串时, 对应的编辑距离dp[0][j]=j, dp[i][0]=i,即直接增加这些字符
  - **状态转移**-当下一个位置上两个字母不同时, dp[i][j]有三种路径转移过来, 取这三种路径的最小值即可
    - dp[i][j-1] + 1, 即从s2[0..j-1]到s2[0..j], 说明再往s2后面加1个字母(等价于s1删去一个字母)
    - dp[i-1][j] + 1, 即从s1[0..i-1]到s1[0..i], 说明再往s1后面加1个字母
    - dp[i - 1][j - 1] + 1, 即s1和s2的下一个位置同时替换掉两个字母即可

> 由于dp本身就是题目要求的内容, 因此跟后序遍历类似, 只要上一层解出来了, 我就可以直接直接得到这一层的结果

- [53-最大子数组和](./maxSubArray2.cpp) dp的定义需要花点功夫
  - **dp含义**-dp[i]表示以nums[i]结尾的最大子数组和, 而非在第i处的最大子数组的和 (因为那样定义dp, 是无法判定**连续子数组**的, 那样成子序列了)
  - **状态转移**-如果nums[i]加上更大了, 那么就加; 否则, **直接归零重新开始** (因为要连续)
    - dp[i] = max(nums[i], dp[i - 1] + nums[i]);
- [1143-最长公共子序列](./longestCommonSubsequence2.cpp), 和编辑距离有点像,
  - **dp含义**-对于dp[i][j]表示s1[0..i]与s2[0..j]的LCS (即LCS这一答案本身)
  - **状态转移**
    - dp[i][j] = dp[i - 1][j - 1] + 1, 当两处字符相同时, 必然在LCS中(因为LCS不连续, 可以尽可能地多放进去)
    - dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当两处字符不相等时, 至少一个不在LCS中, 那么之前LCS的长度不变继续往后看看 (当然往后的时候调最大的走)
- [JZOfferII091-粉刷房子](./minCostPaintHouse.cpp), 三路并行刷房子, 虽然颜色不相同, 但是直接三维dp完事
  - **dp含义**-dp[i][j]表示刷到第i个房子用第j个颜色 (j最大取3)时的最小价钱 (最终答案从dp最后的三个值里选)
  - **状态转移**: dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0] (对于j=0, 就是看其他两个颜色之前的最小值), j=1和2类似
- [712-两个字符串的最小ASCII删除和](./minDeleteDistance.cpp), 与LCS非常像, 只不过把dp的定义变一下
  - **dp含义**: dp[i][j]表示s1[0..i]与s2[0..j]的最小ascii和 (即答案本身)
  - **base case**: 如果是空字符串的话, 就要把自己的所有ascii加起来 (和LCS有点不一样)
  - **状态转移**: 如果相等那就不管, 如果不相等那进行LCS转移的时候加上ascii即可
- [516-最长回文子序列](./longestCommonSubsequence2.cpp), 与LCS和编辑距离都有些像, 但遍历的方向和dp定义需要改变
  - **dp含义**: dp[i][j]表示s[i..j]的最长回文子序列, 即答案本身. 但注意是由内向外的
  - **base case**: `i == j`时, dp为1 (就一个字符); `i > j`时, dp为0
  - **状态转移**: (*此处的遍历方向为*: i需要i+1处的子问题被解决, j需要j-1处的子问题被解决, 同时j >= i + 1)
    - 如果两字符相等, dp[i][j] = dp[i + 1][j - 1] + 2 (最长子序列, 直接加进来)
    - 如果两字符不相等, dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) (从前面的子问题答案转移过来)

> 背包问题中的dp转移思路和序列dp还是有点微妙的差别

- [416-分割等和子集](./canPartition2.cpp): 本质上属于子集0-1背包问题
  - **dp含义**: dp[i][j]表示前i个物品**是否**能装入容量为j的背包, 为布尔值; 最终的答案就是dp[n][cap]
  - **base case**: dp[0][c] = false, dp[k][0] = true
  - **状态转移**: 依然是二维循环对每个i和j进行遍历, 但遍历时首先要注意当前容量必须要大于当前物品 (边界问题)
    - 如果不装当前nums[i]这个物品, dp[i][j]=dp[i - 1][j], 即: 之前那个能装我就能装, 要不能装我也不能装
    - 如果装当前nums[i]这个物品, dp[i][j] = dp[i- 1][j - nums[i]], 即: 之前那个容量刚好能凑满的前提下, 能装我就装, 不能装我也不能装
  - *注意*: 此处转移时并非进行值的变换, 而是布尔值的传递, 并不一定就是true还是false. 因此转移时, 要把每个条件**或**起来
- [518-零钱兑换II](./CoinChange2.cpp): 完全背包和01背包的不同
  - **dp含义**: dp[i][j]表示前i个物品装入容量为j的背包的不同方法个数; 最终的答案就是dp[n][cap]
  - **base case**: dp[0][c] = 0, dp[k][0] = 1 (注意这里是1, 即啥都不做就是唯一的解法)
  - **状态转移**: 依然是二维循环对每个i和j进行遍历, 但遍历时首先要注意当前容量必须要大于当前物品 (边界问题)
    - 如果不装当前coins[i - 1]这个物品, dp[i][j] = dp[i - 1][j], 即: 之前那个是几种方法, 我这个状态还是几种方法 (因为没装, 所以直接继承)
    - 如果装当前coins[i - 1]这个物品, dp[i][j] = dp[i][j - coins[i - 1]], 即: 只要前面容量j - coins[i - 1]能用几种方法凑出来, 那么容量j就能在使用coins[i - 1]的条件下用几种方法凑出来. 
  - 由于物品可被无限次使用, 而`dp[i][j] = dp[i][j - coins[i - 1]]` 这一操作就是表示, 即使物品i被选了, 下次是还能选的, 这也就是完全背包的精髓. 进一步地, 与[322-零钱兑换](./coinChange.cpp)这一01背包问题相比, 可以得到如下结论:
    - dp[i][j] = dp[**i**][j - coins[i - 1]] +dp[i - 1][j] 完全背包，可以重复使用自己
    - dp[i][j] = dp[**i - 1**]][j - coins[i - 1]] +dp[i - 1][j] 01背包，不能重复使用
- [494-目标和](./findTargetSumWays2.cpp): 核心在于将原始问题转换为背包问题, 同时注意base case的不同; 凑出target其实等价于背包容量为 `(sum(nums) + target) / 2`
  - **dp含义**: dp[i][j]表示前i个物品装入容量为j的背包的不同方法个数; 最终的答案就是dp[n][cap]
  - **base case**: dp[0][0] = 1, **dp[k][0]不一定是1** (因为数字为多个0而且target为0的话, 可以选好几种不同的选法)
    - 因此, for循环内层遍历j的时候, 要从**0**开始
  - **状态转移**: 与之前的背包转移完全相同
- [64-最小路径和](./minPathSum2.cpp): 在熟悉dp的思路之后, 这道题可以很快的写出转移方程; 唯一要注意的就是base case怎么写才能和转移方程配合的更好
  - **dp含义**: dp[i][j]表示到位置ij的最小路径和 (即答案本身)
  - **base case**: dp[i][0] = $\sum_{0}^{i}$grid[i][0], 第一行同理 (注意: 可以**先把**第一行第一列的base case算了, 这样转移时的for循环就不用考虑边界问题了) 
  - **状态转移**: dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);, 从正上或左边的最小值转移过来
- [174-地下城游戏](./calculateMinimumHP.cpp): dp的定义依然很关键, 但确实挺难想, 此外还要注意拨动时有顺时针和逆时针两种方向
  - **dp含义**: dp[i][j] or dp(i, j) 表示指针最开始指向ring[i]处时, 最终拨出目标key[j..]的最少步数;
  - **base case**: dp[i][len(key) - 1] = 0
  - **状态转移**: dp[i][j] = min(dp[i][j], 1 + currentStep + dp[IndexOf(key[i])][j + 1]), 即要拨出当前这个位置的最小, 只要后面从`j+1`开始的这些字符能以最小代价拨到`key[i]`即可, 然后再算下从`key[i]`到`ring[i]`的currentStep即可
  - 此外要注意计算currentStep时考虑顺时针和逆时针两种路径
- [787-K 站中转内最便宜的航班](./findCheapestPrice2.cpp), 有点像最短路径或者是什么价格之类的, 只要把k步之内转化为dp的一维即可
  - **dp含义** : dp[i][j] 表示经过i个站点到达j站的最小代价
  - **base case** : dp[0][src] = 0
  - **状态转移** : dp[i][to] = min(dp[i][to], dp[i - 1][all from] + cost), 即遍历所有的flights, 遍历时直接将对应的dp[i][to]更新为最小 (i是最外层循环, 表示第几个站点)
    - 最后的结果即为 min(dp[i][dst]), i <= k + 1, 此外还要注意下dp初始值的问题 (不是INT_MAX, 否则加的时候会溢出)
- [198-打家劫舍](./robI.cpp), 经典的dp题目, 需要从后往前地遍历, 以得到全局的最优 (dp定义不是那么好想)
  - **dp含义** : dp[i]表示从i开始能抢的最大金额, 结果是dp[0]
  - **base case** : dp[n - 1] = house[n - 1]
  - **状态转移** : dp[i] = max(dp[i + 1], house[i] + dp[i + 2]) , 从后往前遍历, 考虑抢和不抢两种情况之间的最大值 (不抢就依然是dp[i + 1], 抢就是当前的house[i] + dp[i + 2])
    - 在已知dp的定义下有两个注意点: 遍历的方向, 怎么处理边界情况?
- [213-打家劫舍II](./robII.cpp), 与198相比, 房间变成了一个圈, 即**首尾相邻**. 这一点转化成了如下情况:
  - (1) 要么第一间房间不抢, 最后一间抢; (2) 要么第一间抢, 最后一间房间不抢
  - 直接套用 198的代码, 看上述两种情况的最大值
  - 关键在于将 **首尾相邻** => **对dp状态和选择的转化** (首尾房间分类讨论)
- [337-打家劫舍 III](./robIII.cpp), 与213和198相比, 所谓的房子成了树状结构. 这一点转化成对一个树节点及其子节点该如何对应到选还是不选上
  - (虽然是dp, 但已经没有传统dp的形态了), 首先考虑树的遍历顺序: 一定是**后序**位置, 即根据子节点的结果往上逐渐考虑, 最后汇聚到root
  - 具体到每个节点的考虑:
    - 当前节点要抢 => 两个子节点不能抢 => 当前节点的值 + 不抢两个子节点时返回的结果
    - 当前节点不抢 => 两个子节点可以抢 => 抢或不抢两个子节点时**结果的最大值**
  - 递归返回即为: {当前节点要抢, 当前节点不抢}, 由此上一层节点就可以用相同的逻辑来计算它自己的值
  - **base case**: 当节点为空时, 返回nullptr

#### leetcode股票买卖问题

- 涉及题目：[121-买卖股票的最佳时机](./maxProfit_I.cpp), [122-买卖股票的最佳时机 II](./maxProfit_II.cpp), [309-最佳买卖股票时机含冷冻期](./maxProfit_II_cooldown.cpp), [714-买卖股票的最佳时机含手续费](./maxProfit_II_fee.cpp), [123-买卖股票的最佳时机 III](./maxProfit_III.cpp), [188-买卖股票的最佳时机 IV](./maxProfit_III_anyk.cpp)
- **dp含义**: dp[i][k][h], 表示在第i天交易次数上限为k且此时持有/不持有股票的情况下的最大金额, 最终结果即为dp[n - 1][k][0] (最后不持有肯定比持有钱多)
  - 注意k是**在交易次数上限为k**的条件下, 而不是已经交易了的次数
- **base case**：(比较tricky的地方)
  - dp[-1][...][0] = dp[...][0][0] = 0; 当状态转移没开始, 或交易上限为0时, 没持有股票自然为0
  - dp[-1][...][1] = dp[...][0][1] = INT_MIN; 当状态转移没开始, 或交易上限为0时, 却持有了股票, 这是不可能边界, 所以设置一个无穷点
  - 在实际代码编写时会发现, 我们只可能给i=0时赋base case, 而根据下面的转移方程可以导出适合i=0时的base case是什么
    - dp[0][...][0] = dp[...][0][0] = 0; dp[0][...][1] = INT_MIN ; dp[...][0][1] = -prices[0];
    - 上式是根据min max以及i=-1时的状态推出的
- **状态转移**:
  - dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]); 
  - dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
- 题目的差异化特征：
  - [121-买卖股票的最佳时机](./maxProfit_I.cpp)：只能买一次，k最大为1，导致其实可以直接省掉对k的枚举
  - [122-买卖股票的最佳时机 II](./maxProfit_II.cpp)：k无穷大，导致对k的枚举没意义，所以也可以省掉
  - [309-最佳买卖股票时机含冷冻期](./maxProfit_II_cooldown.cpp)：在买入时，i只能从i-2转移过来（要处理i=1时的base case）
  - [714-买卖股票的最佳时机含手续费](./maxProfit_II_fee.cpp)：在卖出时扣掉手续费，base case同理
  - [123-买卖股票的最佳时机 III](./maxProfit_III.cpp)：k指定为2，需要对k进行枚举，即一般性的状态转移
  - [188-买卖股票的最佳时机 IV](./maxProfit_III_anyk.cpp)：k指定为任意，当k过大时等价于无穷可复用代码
- 注意点：
  - k的含义, 以及状态转移里k-1变到k意味着什么
  - base case以及实际写代码的时候base case怎么设置
  - 本质上就是对状态的枚举


- [887-鸡蛋掉落](./superEggDrop.cpp): 一道很奇怪的dp题, dp的定义与状态转移非常奇怪
  - 题目解读: 为了确认f去扔鸡蛋的**最坏情况**下的**最小**尝试次数; 最坏指的是鸡蛋破碎发生在**搜索穷尽**之时, 即**最大值中的最小值**
    - 如果采用线性扫描的方法: 最坏情况就是扫描到最后一层楼
  - **两种dp定义**
    - dp[k][n] = m : 常规定义, 即有k个鸡蛋, 要试n层楼时的最小尝试次数m (直接就是结果)
    - dp[k][m] = n : 奇妙定义, 即有k个鸡蛋, 尝试次数上限为m时, **最多有n层楼**可以给我们扔
  - **状态转移**
    - dp[k][i] = max(dp[k][N - i], dp[k - 1][i - 1]), 碎了就试下面i-1层楼, 没碎试试上面N - i层的楼 (只用试更高的)
      - dp停止就是当k和N遍历完了
    - dp[k][i] = dp[k][m - 1] + dp[k - 1][m - 1] + 1, 碎了试试还有更高那些楼能试, 没碎还有下面的楼, 加上自己这层
      - dp停止是当dp[k][..] == N, 即最多有N层楼来试
  - **base case**
    - 1: dp[..][0] = dp[0][..] = 0 and K==1时有结果为N
    - 2: dp[..][0] = dp[0][..] = 0
  - 真的非常奇怪但是还挺重要的一道题
- [312-戳气球](./maxCoins.cpp): 乍一看不知道怎么dp的dp题, 但是只要dp定义出来了, 剩下的都迎刃而解, 非常体现dp思想的题
  - **dp定义**: dp[i][j]表示在(i..j)之间能获得的最大值
    - 但这还没完, 要想到这一层定义隐含的**子问题**也要定义出来, 即令最后一个被戳破的气球是谁? 那么我们定义成k
    - 有了这一点, 再结合戳气球的过程, 就知道要怎么转移了
  - **状态转移**: dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + coins[i] * coins[k] * coins[j])
    - 诚然,这里需要在原本的nums数组前后加上个1, 即形成一个n + 2的数组
    - 这个状态转移就非常的符合题目的模拟过程, 唯一需要的就是明确dp定义, 以及想到最后戳的气球为k这一层; 这样之后就可以递归式的解决子问题了
  - **base case**: dp[i][j] = 0, 其中i >= j. 
  - 其他点: 注意在遍历时, 可以根据base case和最终结果的位置, 画一张图, 然后就可以发现两个索引遍历的顺序
    - i, 即行需要从下往上遍历 (从n而非n+1开始, 因为n+1的时候是0)
    - j, 即列需要从左往右遍历 (从i+1而非i开始, 因为ij都是开区间)
- [486-预测赢家](./PredictTheWinner.cpp): 题目首先要归约成: 就是比先手后手谁钱多这件事. 其次, dp里先手和后手的转换非常巧妙, 以及dp定义的实现和对双方拿取过程的模拟
  - **dp定义**: dp[i][j].first表示在 [i, j] 这个区间里博弈时, 先手方最多能拿多少; dp[i][j].second表示在 [i, j] 这个区间里博弈时, 后手方最多能拿多少
  - **状态转移**: dp[i][j].first = max(pick_left, pick_right), dp[i][j].second = dp[i][j].first拿完之后, 剩下[i+1, j]或者[i, j-1]的先手
    - pick_left = nums[i] + dp[i + 1][j].second;
    - pick_right = nums[j] + dp[i][j - 1].second;
    - 只考虑自己的这一步, 其余的情况其余考虑
  - **base case**: dp[i][i].first = nums[i], dp[i][i].second = 0;
  - 其他点: 由于dp在转移时的方向非常规, 因此两层循环的遍历方向需要思考下. 此外, 这个题的dp结构其实也有点非常规:
    - 一方面, dp的时候有**先后手**的考虑, 当前状态的先手选完后, 在下一状态时就成了后手, 而**当前状态的后手, 其实就是下一状态的先手**
    - 另一方面, dp的状态转移虽然也取决于一个max或者min的选择, 但是因为涉及到了两维 (first与second), 因此需要单独考虑选哪种时的情况, 没法直接max或min一把梭
- [10-正则表达式匹配](./isMatchReg.cpp) 简化版的正则匹配, 对base case的处理属实离谱, 但是对 * 的处理是很符合dp的思想
  - **dp定义**: dp(s, i, p, j) 表示对于字符串s和模式串p, 到索引i和索引j时, 是否有s[i..]匹配p[j..] (布尔值)
  - **状态转移**: 如果下一个字母是*号, 那么就考虑要不要用当前字母来匹配, 用的话就是(i+1, j)去递归, 不用的话就是(i, j+2)去递归
    - if 两个字母可以匹配: dp(s, i, p, j) = dp(s, i + 1, p, j) || dp(s, i, p, j + 2)
    - else (即 * 号只能选择不匹配, 因为字母不一样) : dp(s, i, p, j) = dp(s, i, p, j + 2)
  - **base case**: 当模式串走完时 (j == p.size()), 看字符串走没走完; 当字符串走完时, 只要模式串让 * 号是间隔匹配即可
    - 最终的结果 (递归入口) 即为 dp(s, 0, p, 0);
  - 这个题解的base case真的有点鬼畜, 而且关键在于, 把if那个**两个字母匹配**(相同 or 模式串是 . 号)的情况要写好


## 贪心问题

- [435-无重叠区间](./eraseOverlapIntervals.cpp), 按照区间的右边升序排列, 从第一个开始筛掉和自己重叠的, 然后累积计数
  - **贪心体现在哪里**? 按结束时间排序, 即活动结束得越早越开心, 这样就能参加下一个活动了, 从而就能参加更多的活动. 所以会按结束时间排序
  - **大致过程**: 排序后以第一个结束时间为curr, 循环遍历, 找到下一个区间start >= curr的就可以算, 然后更新curr
  - **相似题目**: [452-用最少数量的箭引爆气球](./findMinArrowShots.cpp), 就是互不重叠的区间的最大个数, 就是需要的最小弓箭数
    - 这道题本质上也是在说 (最多有多少) 互不重叠的区间数, 反过来就是用最少的箭 (用最多的箭那不就是n么)
    - 包括435也是, 反过来就是用移出哪些和候选重叠的区间 (肯定是移最少个, 移最多那不就是n么)

- [1024-视频拼接](./videoStitching2.cpp), 按照区间的左边升序排列, 相等时右边降序排列, 之后每次循环选*最长*的区间, 即贪心, 最后看结尾能不能覆盖time
  - 在排序之后, 所谓最长的区间其实就是, **既要**保证当前区间的结尾(curEnd)覆盖要选的区间的开头, **也要**保证下一个要选的区间的结尾 (nextEnd) 是所有可选区间里最长的那个
  - 排序后, 通过while循环找到 clips[i][0] < curEnd 的同时, nextEnd = max(nextEnd, clips[i][1])的那个区间, 只要找到就可以cnt++
    - 本质上就是 排序 + 贪心式的找区间 (写的时候两个while循环嵌套的思路可以学习下)

- [55-跳跃游戏](./canJumpII.cpp), 需要跳跃的最少次数, 按照贪心思路就是, 每次选择该跳到哪里时, 选择那个能跳到最远地方的位置
  - 道理是这个道理, 但写起来也很有技巧:
    - 每次遍历到为止`i`, `i+nums[i]`就是当前位置的最远位置; 因此, 可以设置一个变量来更新每次遍历时能跳到的最远位置 (就是取max)
    - 然后还维护一个变量来记录所谓的**选择**, 即当选择和当前位置i重叠时, 说明可以从上一个位置跳到了当前位置, 即从上一个位置作出了选择
    - 之后更新这个选择为目前的最远位置 (即**贪心选择**). 注意每次更新选择前都应记录下跳了几次
  - 这样一来, 通过最远贪心来更新每次的选择, 如果在遍历时的索引遇到了这个贪心最远选择, 那么就说明这个选择是可行的, 那就继续贪心 (更新)
  - 这种写法非常妙, 而且短小精悍, 充分利用了最远贪心的这个框架 (反正每个位置都要看看最远能到哪, 不如用一个变量一直max), 然后利用选择来"模拟"跳到自己这个位置的情况
  - **相似题目**: [55-跳跃游戏I](./canJump2.cpp), 类似, 但只用返回是或否, 即单纯地看最远就够了

## 回溯问题

- [46-全排列](./permute2.cpp), 回溯的模板题, 因为是全排列而且不看顺序, 所以直接套回溯的框架就可以写
  - 除了res外, 还需要curr记录当前选择路径, 同时再来一个`used`数组标记哪些数用过了
  - backtrack函数核心就是暴搜, 即for循环内直接进行backtrack递归
  - 就是最基础的回溯讨论, 注意好结束条件, curr清空, used判断即可 

- [51-N 皇后](./solveNQueens.cpp), 由于皇后棋子的规则很粗暴, 所以可以直接按行去摆放,
  - 设置一个`isValid`函数来判定当前位置是否可以摆放皇后棋子 (一旦可以摆放了, 下一次递归时就直接到下一行)
  - `isValid`函数内部分三次对**已经经过**的棋盘位置进行检查: 当前列, 左上, 右上 (覆盖了全部位置)
  - `isValid`通过检查后, 放置皇后 -> 递归 -> 取消放置 (标准的回溯)
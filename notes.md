# 部分题目记录
> 按照知识点归类不同题目，方便后续集中查看回忆

## 链表
- 206反转链表 [reverseList.cpp](./reverseList.cpp)
  - 递归的美妙写法，`reverse(head->next)`, node->next成了最后一个节点, 注意reverse函数的定义
  - **相同题目**: [JZOffer24-反转链表](./reverseList2.cpp), [JZOffer24II-反转链表](./reverseList3.cpp)
  - **相似题目**: [92-反转链表 II](./reverseBetween2.cpp), firstNode节点的定义, 以及先反转前N个节点(比较烧脑的递归)

> 注意: 递归虽然代码非常美妙, 理解也挺烧脑, 但效率是不如迭代的, 要真面试的话, 还是得准备一手迭代的解法


- 876链表的中间结点 [middleNode.cpp](./middleNode.cpp)
  - 每次快指针比慢指针多走一步，慢指针就自然到中间了
- 面试题 02.02. 返回倒数第 k 个节点 [kthToLast](./kthToLast.cpp)
  - 和上面一道题类似,也是快慢指针,让快指针先走k步,慢指针再开始走,经典的思路
  - **相似题目**
    - [JZOfferII021-删除链表的倒数第 n 个结点](./removeNthFromEnd2.cpp), slow指向删的节点, 并保存一个前驱指针, 如果要删除头节点该怎么办
- 面试题02.01.移除重复节点 [removeDuplicateNodes](./removeDuplicateNodes.cpp)
  - 删除节点 + 哈希表，这两个东西结合一下，会产生很多容易写错的细节，多注意一些
- JZOffer18. 删除链表的节点 [deleteNode](./deleteNode3.cpp)
  - 单纯的单链表节点删除, 注意dummy节点的设置以及删除完后直接break
  - **相似题目**: [203-移除链表元素](./removeElements2.cpp), 这一题需要删除多个节点, 注意与上面这个题的不同(cur的移动条件)
- 面试题02.06 回文链表 [isPalindrome](./isPalindromeList.cpp)
  - 链表也能后序遍历？能后序遍历就能实现回文（在递归中left向后走，right每层递归结束都会向前）。非常妙
  - **相同题目**: [JZOfferII027-回文链表](./isPalindromeList2.cpp) (注意递归return的条件)
- 剑指Offer 06. 从尾到头打印链表 [reversePrint](./reversePrint.cpp)
  - 链表的后序遍历（递归法），就是上面那道题的简化版
- 面试题 02.07. 链表相交 [getIntersectionNode](./getIntersectionNode3.cpp)
  - 经典的相交链表问题, 当一个指针走完自己的链表时,让它去遍历另外的链表,这相当于对两条链表的不同部分取并集. 非常经典的思路
  - **相同题目**: [JZOfferII023-两个链表的第一个重合节点](./getIntersectionNode4.cpp) (注意**如果没有相交节点时要返回null时**该怎么办)
- 剑指Offer 25-合并两个排序的链表 [mergeTwoLists](./mergeTwoLists.cpp)
  - 一个while循环 + 两个if判断; 关键在于新链表指针每次都是`cur->next`去操作,cur只用移到`cur->next`即可,省去了空节点的麻烦. 最开始cur就是dummy自己
  - **相同题目**: [21-合并两个有序链表](./mergeTwoLists2.cpp)
  - **相似题目** 
    - [面试题02.05-链表求和](./addTwoNumbers.cpp): 基于链表的按位加模拟过程, 记得设置进位
    - [JZOfferII025-链表中的两数相加](./addTwoNumbers2.cpp): 反向的上一题, 栈的使用 + 反向构建链表(node->next = cur)
    - [23-合并K个升序链表](./mergeKLists.cpp), 优先队列中初始放入所有的头节点, 自己只完成指针的移动即可
    - [61-旋转链表](./rotateRight2.cpp), `p->next=head` 以及移动的是`len-k%len`个节点, 剩余的就是节点next的拆分与更新
- 面试题17.12-BiNode BST展开为链表 [convertBiNode](./convertBiNode.cpp)
  - 本质是BST中序遍历 + 修改指针, 注意left指针修改时要修改当前节点而非上一个节点的.
  - **相似题目**
    - [114-二叉树展开为链表](./flatten2.cpp), 经典的递归定义题目, 核心在于考虑清楚单节点的处理方式, 以及需要在原地空间完成
    - [JZOfferII028-展平多级双向链表](./flattenMultiLevelNode.cpp), 同样从DFS的定义出发, 定义好lastNode后对两端进行操作即可
- 109-有序链表转换二叉搜索树 有序链表构造为BST [sortedListToBST](./sortedListToBST.cpp)
  - 本质是BST中序遍历构造 + 二分, 递归的模板题
  - **相似题目** : [JZOffer36-二叉搜索树与双向链表](./treeToDoublyList.cpp), 直接中序遍历 + 节点的指针修改, 注意递归结束后首尾节点的处理
- 24-两两交换链表中的节点 [swapPairs](./swapPairs2.cpp), 模拟即可, 静下心来想一下就能解决
- 146-LRU 缓存, 经典的面试题, 双向链表 + 哈希表, 需要掌握对功能的分解, LRU的原理, (双向)链表的各种操作.
  - 因为要查找 + 时序 + 删除与插入 , 所以只能双向链表 (删除与插入) + 哈希表 (查找) , 以实现快速的时序
  - 操作过的元素就放在链表最后, 由此头元素就是最久没有被使用的元素
  - 哈希表中存储节点, 负责新元素的get与set, 链表用来维护元素之间的新旧顺序
  - 注意双向链表的插入与删除操作, 语句之间的顺序
- 142-环形链表 II, 经典链表的环相交问题, 快指针比慢指针多走一步, 之后快指针从头开始继续走, 直到相遇 (**画图理解**)
  - 注意: 两指针的相遇点不一定是环的起点!
  - **相同题目**: [JZOfferII022-链表中环的入口节点](./detectCycle3.cpp) (注意可能没有环的返回结构), [面试题02.08-环路检测](./detectCycle4.cpp)
- 面试题04.03-特定深度节点链表: [面试题04.03-特定深度节点链表](./listOfDepth.cpp), BFS层序遍历的模板题目, 兼顾树和链表的结点类型
- JZOffer35-复杂链表的复制 : [copyRandomList](./copyRandomList2.cpp) 两次遍历 + 哈希表方便新建节点 (似乎有更巧妙的方法如dfs, 拆分等)
- 面试题02.04-分割链表[partitionList](./partitionList.cpp), 一个小指针, 一个大指针, 大指针最后别忘了置空
  - **相似题目**: 
    - [JZOfferII026-重排链表](./reorderList2.cpp), 需要用vector来存, 然后跟交换节点很像, 记得最后的节点next置空以及left++


## 树与二叉树

- [104-二叉树的最大深度](./treemaxDepth.cpp): 有多种解法, 考虑分而治之(动规)的思想, 即左子树的最大高度和右子树的最大高度的最大值+1, 就是当前节点的最大深度
  - 后序位置上的遍历, 非常经典的题目, 还可以直接dfs全局变量, bfs遍历等思路去做
  - **相似题目**
    - [543-二叉树的直径](./diameterOfBinaryTree.cpp), 当前节点的最长直径 = 左右子树的最大深度之和, 同样还是后序位置的遍历, 思路与104相同, 只不过单个节点上的操作多了一些.

- [226-翻转二叉树](./invertTree.cpp), 前序和后序位置都可以做, 因为单独到一个节点就是交换左右子树即可, 前序和后序对于这个题而言只是遍历方向不同
- [116-填充每个节点的下一个右侧节点指针](./connectPadNextTree.cpp), 如何访问同辈节点? 递归的时候怎么就抽象成了三叉树?
- [114-二叉树展开为链表](./flatten3.cpp): 典中典之将树展开为链表, 递归求解子问题的经典题目, 即先展开左右子树, 再把左子树接到右子树, 右子树接到新的右子树后面
- [654-最大二叉树](./constructMaximumBinaryTree2.cpp), 分解问题 or 遍历思想? 只取决于怎么理解问题. 对于单个节点而言, 在[left, right] 这个范围里找到最大值后构造节点, 剩下的交给递归.
- 从X序和X序构造二叉树: 给定两个数组, 分别表示前/中/后序的节点, 来构造一颗二叉树 (人脑手写很简单, 那么代码实现呢?)
  - 两个关键点: (1) 快速定位到当前的**根节点** (前序是开始位置, 后序是结束位置); (2) 下一步递归时的**边界计算**, 在中序数组中根据根节点索引和start, 得到**左子树的大小**leftSize, 进行推算
  - 相关题目: [105-从前序与中序遍历序列构造二叉树](./buildTreePreandMid.cpp), [106-从中序与后序遍历序列构造二叉树](./buildTreePostandMid.cpp), [889-根据前序和后序遍历构造二叉树](./constructFromPrePost.cpp), 这一题有些不同, 就是**左子树的大小是不确定**的, 可以强制认为前序中根节点后面那个就是左子树根节点, 然后再用leftSize那些操作.
- [297-二叉树的序列化与反序列化](./Codec2.cpp), 序列化很好实现, 就是前序遍历, 无非自己定义下分隔符和空指针用什么来表示; 反序列化的前序构造要注意两个地方, 对空指针的判定, 和前序构造时全局索引的使用
  - **相似题目**: 
    - [449-序列化和反序列化二叉搜索树](./CodecForBST.cpp), 如果是BST的话, 那就无需空指针了, 通过minv和maxv来判断当前节点值在不在这棵树中
    - [652-寻找重复的子树](./findDuplicateSubtrees.cpp), 序列化仍然是基础, 之后的操作是基于哈希表来判定重复, 注意不要重复添加结果
- [230-二叉搜索树中第K小的元素](./kthSmallest2.cpp), BST的性质让题目理解起来不是很难, 如果用递归去写, 那么就是在遍历的时候维护一个rank记录大小顺序即可
  - 诚然, 也可以用循环的方式去写, 此时手动声明一个stack来存储节点, 人工模拟递归时的迭代方法, 同样还是同时去判断k, 本质和递归是一样的
- [538-把二叉搜索树转换为累加树](./convertSumBST.cpp), 遍历BST得到降序序列/前缀和/etc, right和left的递归位置变一下即可
- [98-验证二叉搜索树](./isValidBST.cpp), 单个节点的BST验证 + 递归时增加maxn minn来进行势力范围的比较
- [701-二叉搜索树中的插入操作](./insertIntoBST.cpp), BST的查找 + 修改. 查找就是二分递归, 修改的话, 如果查找的进程落到了一个null节点的话, 那就得新建一个新节点了, 这就是修改. 记得返回值注意下
- [450-删除二叉搜索树中的节点](./deleteBSTNode.cpp), BST的查找 + 删除, 查找依然遵循着二分递归的框架, 删除的情况略微复杂些: 叶子节点(直接返回空), 只有一个子树(返回这个子树根), 有两个子树(找右子树的最小结点替换当前root作为根)
- [965-单值二叉树](./isUnivalTree.cpp), 判断一个二叉树是否由单单一个值组成, 直接递归判断即可
- [236-二叉树的最近公共祖先], 有点费脑的递归, 前序来保证自身节点选中, 后序保证祖先是深度最深的, 最终left和right哪个非空返回哪个
  - **相似题目**: [235-二叉搜索树的最近公共祖先](./lowestCommonAncestorBST.cpp), 利用BST的性质简化判断
  - tips: 这类题有一个比较核心的点就是, 公共祖先是树结点朝着祖先方向延长线的交点, 而上面两道题的解法框架都涵盖了这一点
- [513-找树左下角的值](./findBottomLeftValue.cpp): 遍历的思想去解决, 遍历时维护一个最大深度, 同时要记得回溯保证当前深度的值是正确的


## 动态规划

- [322-零钱兑换](./coinChange.cpp)
  -  **dp含义**-金额为i时所需的最少硬币数量
  -  **状态转移**-`dp[i]=min(dp[i], dp[i-1] + 1)`, 即再多一个硬币就能从金额i-1凑到i
  -  此外注意下初始值的设定问题
- [300-最长递增子序列](./lengthOfLIS.cpp)
  -  **dp含义**-在位置为i的地方LIS的长度 (双层循环)
  -  **状态转移**-双层循环找比当前nums[i]小的最大的dp[j]+1,就是dp[i]
- [354-俄罗斯套娃信封问题](./maxEnvelopes2.cpp) : 先按宽升序排列, **宽相等的**再按照高降序排列
  -  直接N方的dp在lc上会超时, 需要用耐心排序的二分实现达到NlogN的复杂度, 每次二分查找找比当前牌小的堆顶, 堆数就是LIS
- [931-下降路径最小和](./minFallingPathSum.cpp): 二维dp, 边界值和初始值的设定比较容易出错
  -  **dp含义**-在位置ij处的最小路径和
  -  **状态转移**-当前matrix_ij的权重加上上一层dp的最小值 (最小值来自三个方向, 为维护代码统一性, 需考虑边界问题和缺省值的设定)
- [72-编辑距离](./EditDistance.cpp): 大名鼎鼎的编辑距离, dp还是递归, 异曲同工, 都是靠上一层的结果直接求解这一层的结果
  - **dp含义**-对于dp[i][j]表示s1[0..i]变换到s2[0..j]的最小次数 (即编辑距离这一答案本身)
  - **base case**-当s1或s2有任意一方为空字符串时, 对应的编辑距离dp[0][j]=j, dp[i][0]=i,即直接增加这些字符
  - **状态转移**-当下一个位置上两个字母不同时, dp[i][j]有三种路径转移过来, 取这三种路径的最小值即可
    - dp[i][j-1] + 1, 即从s2[0..j-1]到s2[0..j], 说明再往s2后面加1个字母(等价于s1删去一个字母)
    - dp[i-1][j] + 1, 即从s1[0..i-1]到s1[0..i], 说明再往s1后面加1个字母
    - dp[i - 1][j - 1] + 1, 即s1和s2的下一个位置同时替换掉两个字母即可

> 由于dp本身就是题目要求的内容, 因此跟后序遍历类似, 只要上一层解出来了, 我就可以直接直接得到这一层的结果

- [53-最大子数组和](./maxSubArray2.cpp) dp的定义需要花点功夫
  - **dp含义**-dp[i]表示以nums[i]结尾的最大子数组和, 而非在第i处的最大子数组的和 (因为那样定义dp, 是无法判定**连续子数组**的, 那样成子序列了)
  - **状态转移**-如果nums[i]加上更大了, 那么就加; 否则, **直接归零重新开始** (因为要连续)
    - dp[i] = max(nums[i], dp[i - 1] + nums[i]);
- [1143-最长公共子序列](./longestCommonSubsequence2.cpp), 和编辑距离有点像,
  - **dp含义**-对于dp[i][j]表示s1[0..i]与s2[0..j]的LCS (即LCS这一答案本身)
  - **状态转移**
    - dp[i][j] = dp[i - 1][j - 1] + 1, 当两处字符相同时, 必然在LCS中(因为LCS不连续, 可以尽可能地多放进去)
    - dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当两处字符不相等时, 至少一个不在LCS中, 那么之前LCS的长度不变继续往后看看 (当然往后的时候调最大的走)
- [JZOfferII091-粉刷房子](./minCostPaintHouse.cpp), 三路并行刷房子, 虽然颜色不相同, 但是直接三维dp完事
  - **dp含义**-dp[i][j]表示刷到第i个房子用第j个颜色 (j最大取3)时的最小价钱 (最终答案从dp最后的三个值里选)
  - **状态转移**: dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0] (对于j=0, 就是看其他两个颜色之前的最小值), j=1和2类似
- [712-两个字符串的最小ASCII删除和](./minDeleteDistance.cpp), 与LCS非常像, 只不过把dp的定义变一下
  - **dp含义**: dp[i][j]表示s1[0..i]与s2[0..j]的最小ascii和 (即答案本身)
  - **base case**: 如果是空字符串的话, 就要把自己的所有ascii加起来 (和LCS有点不一样)
  - **状态转移**: 如果相等那就不管, 如果不相等那进行LCS转移的时候加上ascii即可
- [516-最长回文子序列](./longestCommonSubsequence2.cpp), 与LCS和编辑距离都有些像, 但遍历的方向和dp定义需要改变
  - **dp含义**: dp[i][j]表示s[i..j]的最长回文子序列, 即答案本身. 但注意是由内向外的
  - **base case**: `i == j`时, dp为1 (就一个字符); `i > j`时, dp为0
  - **状态转移**: (*此处的遍历方向为*: i需要i+1处的子问题被解决, j需要j-1处的子问题被解决, 同时j >= i + 1)
    - 如果两字符相等, dp[i][j] = dp[i + 1][j - 1] + 2 (最长子序列, 直接加进来)
    - 如果两字符不相等, dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) (从前面的子问题答案转移过来)

> 背包问题中的dp转移思路和序列dp还是有点微妙的差别

- [416-分割等和子集](./canPartition2.cpp): 本质上属于子集0-1背包问题
  - **dp含义**: dp[i][j]表示前i个物品**是否**能装入容量为j的背包, 为布尔值; 最终的答案就是dp[n][cap]
  - **base case**: dp[0][c] = false, dp[k][0] = true
  - **状态转移**: 依然是二维循环对每个i和j进行遍历, 但遍历时首先要注意当前容量必须要大于当前物品 (边界问题)
    - 如果不装当前nums[i]这个物品, dp[i][j]=dp[i - 1][j], 即: 之前那个能装我就能装, 要不能装我也不能装
    - 如果装当前nums[i]这个物品, dp[i][j] = dp[i- 1][j - nums[i]], 即: 之前那个容量刚好能凑满的前提下, 能装我就装, 不能装我也不能装
  - *注意*: 此处转移时并非进行值的变换, 而是布尔值的传递, 并不一定就是true还是false. 因此转移时, 要把每个条件**或**起来
- [518-零钱兑换II](./CoinChange2.cpp): 完全背包和01背包的不同
  - **dp含义**: dp[i][j]表示前i个物品装入容量为j的背包的不同方法个数; 最终的答案就是dp[n][cap]
  - **base case**: dp[0][c] = 0, dp[k][0] = 1 (注意这里是1, 即啥都不做就是唯一的解法)
  - **状态转移**: 依然是二维循环对每个i和j进行遍历, 但遍历时首先要注意当前容量必须要大于当前物品 (边界问题)
    - 如果不装当前coins[i - 1]这个物品, dp[i][j] = dp[i - 1][j], 即: 之前那个是几种方法, 我这个状态还是几种方法 (因为没装, 所以直接继承)
    - 如果装当前coins[i - 1]这个物品, dp[i][j] = dp[i][j - coins[i - 1]], 即: 只要前面容量j - coins[i - 1]能用几种方法凑出来, 那么容量j就能在使用coins[i - 1]的条件下用几种方法凑出来. 
  - 由于物品可被无限次使用, 而`dp[i][j] = dp[i][j - coins[i - 1]]` 这一操作就是表示, 即使物品i被选了, 下次是还能选的, 这也就是完全背包的精髓. 进一步地, 与[322-零钱兑换](./coinChange.cpp)这一01背包问题相比, 可以得到如下结论:
    - dp[i][j] = dp[**i**][j - coins[i - 1]] +dp[i - 1][j] 完全背包，可以重复使用自己
    - dp[i][j] = dp[**i - 1**]][j - coins[i - 1]] +dp[i - 1][j] 01背包，不能重复使用
- [494-目标和](./findTargetSumWays2.cpp): 核心在于将原始问题转换为背包问题, 同时注意base case的不同; 凑出target其实等价于背包容量为 `(sum(nums) + target) / 2`
  - **dp含义**: dp[i][j]表示前i个物品装入容量为j的背包的不同方法个数; 最终的答案就是dp[n][cap]
  - **base case**: dp[0][0] = 1, **dp[k][0]不一定是1** (因为数字为多个0而且target为0的话, 可以选好几种不同的选法)
    - 因此, for循环内层遍历j的时候, 要从**0**开始
  - **状态转移**: 与之前的背包转移完全相同
- [64-最小路径和](./minPathSum2.cpp): 在熟悉dp的思路之后, 这道题可以很快的写出转移方程; 唯一要注意的就是base case怎么写才能和转移方程配合的更好
  - **dp含义**: dp[i][j]表示到位置ij的最小路径和 (即答案本身)
  - **base case**: dp[i][0] = $\sum_{0}^{i}$grid[i][0], 第一行同理 (注意: 可以**先把**第一行第一列的base case算了, 这样转移时的for循环就不用考虑边界问题了) 
  - **状态转移**: dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);, 从正上或左边的最小值转移过来
- [174-地下城游戏](./calculateMinimumHP.cpp) todo
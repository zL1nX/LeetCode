/*
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。

第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。

找出并返回 n 轮后有多少个亮着的灯泡。

 

示例 1：



输入：n = 3
输出：1 
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。
示例 2：

输入：n = 0
输出：0
示例 3：

输入：n = 1
输出：1
 

提示：

0 <= n <= 109
通过次数27,269提交次数50,499

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/bulb-switcher
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/
#include <math.h>

using namespace std;

int bulbSwitch(int n) 
{
    return (int)sqrt(n);
}

//本来想模拟的，没想到是脑筋急转弯

// 将灯泡从1到k编号，会发现编号为k的灯泡在第 k的因子 次都会被切换开关（第6个灯泡在第1、2、3、6次都会被切换）

// 所以，k有偶数个因子的话，最终就是暗的；k有奇数个因子的话，最终就是亮的

// 而如果只有奇数个因子，说明这个数一定是完全平方数，否则那些因子就会成对出现，从而是偶数个

// 题目就是要问 [1, n] 之间的完全平方数的个数

// 而因为小于等于n的数中，要成为完全平方数，只有可能是小于等于 sqrt(n)的那些整数才能形成完全平方数 （对这些数进行平方后就是n内的完全平方数）

// 所以sqrt(n)向下取整本身就是完全平方数的个数

// 但最后这一点很多题解并没有说明

// 这题也是真彳亍
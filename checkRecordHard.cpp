/*
可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
'A'：Absent，缺勤
'L'：Late，迟到
'P'：Present，到场
如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：

按 总出勤 计，学生缺勤（'A'）严格 少于两天。
学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。

 

示例 1：

输入：n = 2
输出：8
解释：
有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
示例 2：

输入：n = 1
输出：3
示例 3：

输入：n = 10101
输出：183236316
 

提示：

1 <= n <= 105
通过次数8,704提交次数17,164

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/student-attendance-record-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

#include <vector>

using namespace std;

const int mod = 1e9 + 7;

int checkRecordHard(int n) 
{
    long dp[2][3][n + 1];
    // 当长度为1时，只有这几种初始的奖励情况
    dp[0][0][1] = 1;
    dp[0][1][1] = 1;
    dp[1][0][1] = 1;
    for(int len = 2; len <= n; len++)
    {
        dp[0][0][len] = (dp[0][0][len - 1] + dp[0][1][len - 1] + dp[0][2][len - 1]) % mod;
        // 没有A和连续的三个L，说明前一个状态也不能有A，或者可以有0、1、2个连续的L，但新加的这个不是
        dp[0][1][len] = dp[0][0][len - 1] % mod;
        // 没有A 和 连续的1个L，只有从0个连续的L转移来
        dp[1][0][len] = (dp[0][0][len - 1] + dp[0][1][len - 1]+dp[0][2][len - 1] + dp[1][0][len - 1] + \
        dp[1][1][len - 1] + dp[1][2][len - 1]) % mod;
        // 同理，这个状态就会多些
        dp[1][1][len] = dp[1][0][len - 1] % mod;
        // 要有连续的1个L，那么下一个末尾必须加L，所以只有后面这一种情况
        dp[0][2][len] = dp[0][1][len - 1] % mod;
        // 同理，上一个状态末尾必须有1个L
        dp[1][2][len] = dp[1][1][len - 1] % mod;
        //  同理
    }
    return (dp[0][0][n] + dp[0][1][n] + dp[0][2][n] + dp[1][0][n] + dp[1][1][n] + dp[1][2][n]) % mod;
    //其实，循环中的六个状态 就是能获得奖励的6种情况，最终将它们累加起来就是所有的获奖情况
}

// 这种写法的确能再次加深对dp的理解，啥动态不动态的，明明就是缓存+预计算

// 首先明确，咱们要计算的是，能获得奖励的排法。

// 之后给出dp的定义是，ijk分别代表有几个A、末尾连续的几个j，以及此时长度为k，的奖励方案

// 那么最终所谓的能获得奖励，就是看k=n时，前面ij分别取若干个满足条件的值时的奖励方案之和

// 因此初始时，就可以从k=1时的几种能奖励的情况，按长度去遍历，每轮循环遍历所有的能被奖励的情况

// 然后最后累加这些能被奖励的结果即可

// 可以多连几遍